<!DOCTYPE html>
<html>
<head>
	<title>Test</title>

	<script src="js/helvetiker.typeface.js"></script>
	<!-- <script src="js/aircut_light.typeface.js"></script> -->
	<!-- <script src="js/airmole_shaded_regular.typeface.js"></script> -->
	<script src="js/utils.js"></script>
	
	<script>
		var canvas;
		var ctx;
		var style = {
			fontStretchPercent: 1,
			fontSize: 30,
			letterSpacing: 0
		};
		
		
		var line1 = "Lorem ipsum dolor sit amet, consectetur \nadipiscing elit.";
		var line2 = "Donec tempus, quam nec pellentesque imperdiet, nunc leo vehicula justo, sed feugiat lacus leo a sem. Ut in nibh id orci";
		var line3 = "sagittis mollis. Donec pretium fermentum mi, eget aliquet libero egestas a. Aenean molestie ligula at eros auctor in facilisis";
		function init() {
			canvas = document.getElementById("mainCanvas");
			ctx = canvas.getContext("2d");
			
			ctx.fillStyle = "#CCC";
			
			speechBubble(ctx, 10, 10, 275, 120, 15, 10 + 20, 10 + 120 + 20, -Math.PI/4);
			ctx.save();
			ctx.translate(25, 20);
			renderTextLimitWidth(ctx, line1, {
				maxWidth: 300
			});
			ctx.restore();
			
			
			
			/*ctx.translate(0, lineHeight);
			renderText(ctx, line2);
			ctx.translate(0, Math.round(this.pixelsFromPoints(face, style, face.lineHeight)));
			renderText(ctx, line3);*/
			// 
			
			//roundedRect(ctx, 50, 50, 100, 70, 15);
//			ctx.moveTo(100, 100);
//			ctx.lineTo(250, 100);
			//ctx.stroke();
			
//			animate();
		}
		
		function renderTextLimitWidth(ctx, text, extra) {
			var lines = text.split("\n");
			
			var lineHeight = Math.round(this.pixelsFromPoints(face, style, face.lineHeight));
			
			var pointScale = pixelsFromPoints(face, style, 1);

			
			for (var i = 0; i < lines.length; i++) {
				var line = lines[i];
				var extents = getTextExtents(face, style, line);
				var lineWidth = extents.x*pointScale;
				
				if (lineWidth < extra.maxWidth) {
					// ctx.fillRect(0, 0, extents.x*pointScale, lineHeight);
					renderLine(ctx, lines[i]);
					var lineHeight = Math.round(this.pixelsFromPoints(face, style, face.lineHeight));
					ctx.translate(0, lineHeight);					
				} else {
					var words = line.split(" ");
					var firstLine = words[0];
					var i = 1;
					while (true) {
						var word = words[i++];
						extents = getTextExtents(face, style, firstLine);
						lineWidth = extents.x*pointScale;
						var wordExtents = getTextExtents(face, style, " " + wordExtents);
						var wordWidth = wordExtents.x*pointScale;
						if (wordWidth + lineWidth > extra.maxWidth) {
							renderTextLimitWidth(ctx, firstLine, extra);
							renderTextLimitWidth(ctx, line.substring(firstLine.length + 1), extra);
							break;
						} else {
							firstLine += " " + word;
						}
					}
				}
			}
		}
		
		function renderText(ctx, text, extra) {
			var lines = text.split("\n");
			
			var lineHeight = Math.round(this.pixelsFromPoints(face, style, face.lineHeight));
			
			var pointScale = pixelsFromPoints(face, style, 1);

			
			for (var i = 0; i < lines.length; i++) {
				var extents = getTextExtents(face, style, lines[i]);
				ctx.fillRect(0, 0, extents.x*pointScale, lineHeight);

				renderLine(ctx, lines[i]);
				
				var lineHeight = Math.round(this.pixelsFromPoints(face, style, face.lineHeight));
				ctx.translate(0, lineHeight);
			}
		}
		
		function renderLine(ctx, text) {
			ctx.save();
			ctx.beginPath();
			var pointScale = pixelsFromPoints(face, style, 1);
			ctx.scale(pointScale * style.fontStretchPercent, -1 * pointScale);
			ctx.translate(0, -1 * face.ascender);
			
			ctx.strokeStyle = "green";
			//ctx.fillStyle = "#EEEEEE";
			ctx.fillStyle = "#333";
			//renderGlyph (ctx, face, 'S', style);
			_renderWord (ctx, face, style, text);
			ctx.fill();
			ctx.stroke();
			
			ctx.restore();
		}
		
	function getTextExtents(face, style, text) {
		var extentX = 0;
		var extentY = 0;
		var horizontalAdvance;
	
		
		var textLength = text.length;
		for (var i = 0; i < textLength; i++) {
			
			var glyph = face.glyphs[text.charAt(i)] ? face.glyphs[text.charAt(i)] : face.glyphs[this.fallbackCharacter];
			
			var letterSpacingAdjustment = pointsFromPixels(face, style, style.letterSpacing);
			// if we're on the last character, go with the glyph extent if that's more than the horizontal advance
			extentX += i + 1 == textLength ? Math.max(glyph.x_max, glyph.ha) : glyph.ha;
			extentX += letterSpacingAdjustment;

			horizontalAdvance += glyph.ha + letterSpacingAdjustment;
			
		}
		return { 
			x: extentX, 
			y: extentY,
			ha: horizontalAdvance
			
		};
	}
	
	function pointsFromPixels(face, style, pixels, dimension) {
		var points = pixels * face.resolution / (parseInt(style.fontSize) * 72 / 100);
		if (dimension == 'horizontal' && style.fontStretchPrecent) {
			points *= style.fontStretchPercent;
		}
		return points;
	}

		
		function _renderWord(ctx, face, style, text) {
//				var surface = this.initializeSurface(face, style, text);
//				var ctx = surface.context;
//				var canvas = surface.canvas;
//				ctx.beginPath();
//				ctx.save();

				var chars = text.split('');
				var charsLength = chars.length;
				for (var i = 0; i < charsLength; i++) {
					renderGlyph(ctx, face, chars[i], style);
				}


/*				if (style.textDecoration == 'underline') {

					ctx.beginPath();
					ctx.moveTo(0, face.underlinePosition);
					ctx.restore();
					ctx.lineTo(0, face.underlinePosition);
					ctx.strokeStyle = style.color;
					ctx.lineWidth = face.underlineThickness;
					ctx.stroke();
				}

				return { element: ctx.canvas, width: Math.floor(canvas.width) }; */
			
			}
		
		function pixelsFromPoints(face, style, points, dimension) {
			var pixels = points * parseInt(style.fontSize) * 72 / (face.resolution * 100);
			if (dimension == 'horizontal' && style.fontStretchPercent) {
				pixels *= style.fontStretchPercent;
			}
			return pixels;
		}
		
		
		function speechBubble(ctx, x, y, width, height, radius, tailX, tailY, tailAngle) { 
			
			var ix = tailX - (tailY - (y + height))/Math.tan(tailAngle);
			var iy = y + height;
			
			var ix1 = ix - 7;
			var ix2 = ix + 7;
			
			ctx.beginPath(); 

			// draw top and top right corner 
			ctx.moveTo(x + radius, y); 
			ctx.arcTo(x + width, y, x + width, y + radius, radius); 
			
			// draw right side and bottom right corner 
			ctx.arcTo(x+width,y+height,x+width-radius,y+height,radius); 

			// go to first intersection with the tail
			ctx.lineTo(ix2, iy);
			ctx.lineTo(tailX, tailY);
			ctx.lineTo(ix1, iy);
			
			// draw bottom and bottom left corner 
			ctx.arcTo(x,y+height,x,y+height-radius,radius); 
			
			// draw left and top left corner 
			ctx.arcTo(x,y,x+radius,y,radius);

			ctx.stroke();
			
			
			
			//ctx.moveTo(tailX, tailY);
			//ctx.lineTo(ix, iy);
			//ctx.stroke();
		}
		
		function renderGlyph (ctx, face, char, style) {
				var glyph = face.glyphs[char];

				if (!glyph) {
					//this.log.error("glyph not defined: " + char);
					return this.renderGlyph(ctx, face, this.fallbackCharacter, style);
				}

				if (glyph.o) {

					var outline;
					if (glyph.cached_outline) {
						outline = glyph.cached_outline;
					} else {
						outline = glyph.o.split(' ');
						glyph.cached_outline = outline;
					}

					var outlineLength = outline.length;
					for (var i = 0; i < outlineLength; ) {

						var action = outline[i++];

						switch(action) {
							case 'm':
								ctx.moveTo(outline[i++], outline[i++]);
								break;
							case 'l':
								ctx.lineTo(outline[i++], outline[i++]);
								break;

							case 'q':
								var cpx = outline[i++];
								var cpy = outline[i++];
								ctx.quadraticCurveTo(outline[i++], outline[i++], cpx, cpy);
								break;

							case 'b':
								var x = outline[i++];
								var y = outline[i++];
								ctx.bezierCurveTo(outline[i++], outline[i++], outline[i++], outline[i++], x, y);
								break;
						}
					}					
				}
				if (glyph.ha) {
					var letterSpacingPoints = 
						style.letterSpacing && style.letterSpacing != 'normal' ? 
							this.pointsFromPixels(face, style, style.letterSpacing) : 
							0;

					ctx.translate(glyph.ha + letterSpacingPoints, 0);
				}
			}

		
		function roundedRect(ctx, x, y, width, height, radius) { 
			ctx.beginPath(); 

			// draw top and top right corner 
			ctx.moveTo(x + radius, y); 
			ctx.arcTo(x + width, y, x + width, y + radius, radius); 
			
			// draw right side and bottom right corner 
			ctx.arcTo(x+width,y+height,x+width-radius,y+height,radius); 

			// draw bottom and bottom left corner 
			ctx.arcTo(x,y+height,x,y+height-radius,radius); 
			
			// draw left and top left corner 
			ctx.arcTo(x,y,x+radius,y,radius); 
		}
		

		
		function arrow(ctx) {
			ctx.strokeStyle='rgb(50,50,0)';
			ctx.fillStyle='rgb(50,50,0)'; 
			ctx.lineWidth=2; 
			
			// draw the line for the shaft 
			
			ctx.moveTo(10,30); 
			ctx.lineTo(290,30); 
			
			// draw the top of the arrow head 
			ctx.lineTo(285,28); 
			
			// draw the curve of the back 
			ctx.arcTo(289,30, 285,32,8); 
			
			// draw the bottom of the arrow head 
			ctx.lineTo(290,30); 
			
			// and make it draw 
			ctx.stroke(); 
			ctx.fill();
			ctx.fill();
		}
	</script>
	
	  <script type="text/javascript">
        Filters = {};
        Filters.getPixels = function(img) {
          var c,ctx;
          if (img.getContext) {
            c = img;
            try { ctx = c.getContext('2d'); } catch(e) {}
          }
          if (!ctx) {
            c = this.getCanvas(img.width, img.height);
            ctx = c.getContext('2d');
            ctx.drawImage(img, 0, 0);
          }
          return ctx.getImageData(0,0,c.width,c.height);
        };

        Filters.getCanvas = function(w,h) {
          var c = document.createElement('canvas');
          c.width = w;
          c.height = h;
          return c;
        };

        Filters.filterImage = function(filter, ctx, var_args) {
          var args = [ctx.getImageData(0, 0, canvas.width, canvas.height)];
          for (var i=2; i<arguments.length; i++) {
            args.push(arguments[i]);
          }
          return filter.apply(null, args);
        };

        Filters.grayscale = function(pixels, args) {
          var d = pixels.data;
          for (var i=0; i<d.length; i+=4) {
            var r = d[i];
            var g = d[i+1];
            var b = d[i+2];
            // CIE luminance for the RGB
            var v = 0.2126*r + 0.7152*g + 0.0722*b;
            d[i] = d[i+1] = d[i+2] = v
          }
          return pixels;
        };

        Filters.brightness = function(pixels, adjustment) {
          var d = pixels.data;
          for (var i=0; i<d.length; i+=4) {
            d[i] += adjustment;
            d[i+1] += adjustment;
            d[i+2] += adjustment;
          }
          return pixels;
        };

        Filters.threshold = function(pixels, threshold) {
          var d = pixels.data;
          for (var i=0; i<d.length; i+=4) {
            var r = d[i];
            var g = d[i+1];
            var b = d[i+2];
            var v = (0.2126*r + 0.7152*g + 0.0722*b >= threshold) ? 255 : 0;
            d[i] = d[i+1] = d[i+2] = v
          }
          return pixels;
        };

        Filters.tmpCanvas = document.createElement('canvas');
        Filters.tmpCtx = Filters.tmpCanvas.getContext('2d');

        Filters.createImageData = function(w,h) {
          return this.tmpCtx.createImageData(w,h);
        };

        Filters.convolute = function(pixels, weights, opaque) {
          var side = Math.round(Math.sqrt(weights.length));
          var halfSide = Math.floor(side/2);

          var src = pixels.data;
          var sw = pixels.width;
          var sh = pixels.height;

          var w = sw;
          var h = sh;
          var output = Filters.createImageData(w, h);
          var dst = output.data;

          var alphaFac = opaque ? 1 : 0;

          for (var y=0; y<h; y++) {
            for (var x=0; x<w; x++) {
              var sy = y;
              var sx = x;
              var dstOff = (y*w+x)*4;
              var r=0, g=0, b=0, a=0;
              for (var cy=0; cy<side; cy++) {
                for (var cx=0; cx<side; cx++) {
                  var scy = Math.min(sh-1, Math.max(0, sy + cy - halfSide));
                  var scx = Math.min(sw-1, Math.max(0, sx + cx - halfSide));
                  var srcOff = (scy*sw+scx)*4;
                  var wt = weights[cy*side+cx];
                  r += src[srcOff] * wt;
                  g += src[srcOff+1] * wt;
                  b += src[srcOff+2] * wt;
                  a += src[srcOff+3] * wt;
                }
              }
              dst[dstOff] = r;
              dst[dstOff+1] = g;
              dst[dstOff+2] = b;
              dst[dstOff+3] = a + alphaFac*(255-a);
            }
          }
          return output;
        };

        if (!window.Float32Array)
          Float32Array = Array;

        Filters.convoluteFloat32 = function(pixels, weights, opaque) {
          var side = Math.round(Math.sqrt(weights.length));
          var halfSide = Math.floor(side/2);

          var src = pixels.data;
          var sw = pixels.width;
          var sh = pixels.height;

          var w = sw;
          var h = sh;
          var output = {
            width: w, height: h, data: new Float32Array(w*h*4)
          };
          var dst = output.data;

          var alphaFac = opaque ? 1 : 0;

          for (var y=0; y<h; y++) {
            for (var x=0; x<w; x++) {
              var sy = y;
              var sx = x;
              var dstOff = (y*w+x)*4;
              var r=0, g=0, b=0, a=0;
              for (var cy=0; cy<side; cy++) {
                for (var cx=0; cx<side; cx++) {
                  var scy = Math.min(sh-1, Math.max(0, sy + cy - halfSide));
                  var scx = Math.min(sw-1, Math.max(0, sx + cx - halfSide));
                  var srcOff = (scy*sw+scx)*4;
                  var wt = weights[cy*side+cx];
                  r += src[srcOff] * wt;
                  g += src[srcOff+1] * wt;
                  b += src[srcOff+2] * wt;
                  a += src[srcOff+3] * wt;
                }
              }
              dst[dstOff] = r;
              dst[dstOff+1] = g;
              dst[dstOff+2] = b;
              dst[dstOff+3] = a + alphaFac*(255-a);
            }
          }
          return output;
        };
		
		
	/// 
	function test(ctx) {
		var c = 1/9;
		var idata = Filters.filterImage(Filters.convolute, ctx, 
			[ c, c, c,
              c, c, c,
              c, c, c ]);
		ctx.putImageData(idata, 0, 0);
	}
		
  </script>
</head>

<body onload="init()">
	<canvas id="mainCanvas" width="300" height="300" onclick="test(ctx)"></canvas>
	
</body>
</html> 