<!DOCTYPE html>
<html>
<head>
	<title>Test</title>

	<script src="js/utils.js"></script>

	<script src="js/EventEmitter.js"></script>

	<script src="js/input/InputHandlerBase.js"></script>
	<script src="js/input/MouseInputHandler.js"></script>
	<script src="js/input/TouchInputHandler.js"></script>
	<script src="js/input/InputHandler.js"></script>

	<script src="js/gl-matrix.js"></script>
	
	<script src="js/Agent.js"></script>
	<script src="js/Obstacle.js"></script>
	<script src="js/Marker.js"></script>
	<script src="js/MoveToBehavior.js"></script>
	
	<script>
	
		function sign(number) {
			return number > 0 ? 1 : number == 0 ? 0 : -1;
		}
		
		function copy(v) {
			return [v[0], v[1]];
		}
	
		function normalize(vec) {
			setLength(vec, 1);
		}
		
		function length(vec) {
			return Math.sqrt(vec[0]*vec[0] + vec[1]*vec[1]);
		}
		
		function divide(vec, scalar) {
			vec[0] /= scalar;
			vec[1] /= scalar;
		}

		function multiply(vec, scalar) {
			vec[0] *= scalar;
			vec[1] *= scalar;
		}
		
		function setLength(vec, len) {
			if (!(vec[0] || vec[1])) {
				return;
			}
			var curLen = length(vec);
			var c = len/curLen;
			multiply(vec, c);
		}
		
		function trim(v, max) {
			if (length(v) > max) {
				setLength(v, max);
			}
		}
		
		function LookAtBehavior(x, y) {
			this.dest = vec2.createFrom(x, y);
		}
		
		_p = LookAtBehavior.prototype;
		
		_p.applyToAgent = function(time, agent) {
			var acceptDistance = 0.01;
			var rotationSpeed = 0.002;
			
			//debugger;
			var targetAngle = vec2.subtract(this.dest, agent.pos, vec2.create());
			var targetOrientation = Math.atan2(-targetAngle[0], targetAngle[1]) + Math.PI/2;
			
			var deltaOrientation = targetOrientation - agent.orientation;
			
			while (deltaOrientation > Math.PI) {
				deltaOrientation -= Math.PI*2;
			}
			while (deltaOrientation < -Math.PI) {
				deltaOrientation += Math.PI*2;
			}
			
			//console.log(deltaOrientation + "|" + targetOrientation);
			
			var rot = sign(deltaOrientation)*Math.min(rotationSpeed, Math.abs(deltaOrientation));
			
			
			var done = false;
			if (Math.abs(rot*time) > Math.abs(deltaOrientation)) {
				rot = deltaOrientation/time;
				done = true;
			}
			
			agent.orientation += rot*time;
			
			return done;
		};
		
		function BehaviorManager(agent) {
			this.behaviors = [];
			this.current = 0;
			this.agent = agent;
		}
		
		_p = BehaviorManager.prototype;
		
		_p.add = function (behavior) {
			this.behaviors.push(behavior);
		};
		
		_p.update = function (time) {
			if (this.behaviors[this.current]) {
				var behavior = this.behaviors[this.current];
				if (behavior.applyToAgent(time, this.agent)) {
					agent.stop();
					this.current++;
				}
			}
		}
	</script>
	
	<script>
		var canvas;
		var ctx;
		var lastUpdate = Date.now();
		
		var agent = new Agent();

		var markers = [
			new Marker(150, 300),
			new Marker(150, 100)
		];

		var input;

		var obstacle = new Obstacle([
			[100, 100],
			[70, 140],
			[130, 140]
		]);
		
		var bManager = new BehaviorManager(agent);
		
		// bManager.add(new LookAtBehavior(marker.x, marker.y));
		bManager.add(new LookAtBehavior(markers[0].x, markers[0].y));
		bManager.add(new MoveToBehavior(markers[0].x, markers[0].y));
		bManager.add(new LookAtBehavior(markers[1].x, markers[1].y));
		bManager.add(new MoveToBehavior(markers[1].x, markers[1].y));

		
		function init() {
			canvas = document.getElementById("mainCanvas");
			input = new InputHandler(canvas);
			input.on("down", function(e) {
				markers.push(new Marker(e.x, e.y));
				bManager.add(new LookAtBehavior(e.x, e.y));
				bManager.add(new MoveToBehavior(e.x, e.y));
			});
			ctx = canvas.getContext("2d");
			animate();
		}
		
		function animate() {
			var time = Date.now() - lastUpdate;
			lastUpdate = Date.now();
			requestAnimationFrame(arguments.callee);
			
			update(time);
			drawFrame(time);
		}
		
		function update(time) {
			bManager.update(time);
			//behavior.applyToAgent(time, agent);
			agent.update(time);
		}
		
		function drawFrame() {
			drawGrid(ctx);

			for (var i = 0; i < markers.length; i++) {
				markers[i].draw(ctx);
			}
			agent.draw(ctx);
			// obstacle.draw(ctx);
			
			/*
			ctx.beginPath(); // 
			ctx.arc(100, 100, 50, 0, Math.PI/4, false);
			ctx.lineTo(100, 100);
			ctx.closePath();
			ctx.fill(); */
		}
		
		function drawGrid(ctx) {
			ctx.fillStyle = "white";
			ctx.fillRect(0, 0, canvas.width, canvas.height);
			
			var cellSize = 25;
			
			ctx.beginPath();
			for (var i = 0; i < canvas.width/cellSize; i++) {
				ctx.moveTo(i*cellSize + 0.5, 0);
				ctx.lineTo(i*cellSize + 0.5, canvas.height);
			}

			for (var j = 0; j < canvas.height/cellSize; j++) {
				ctx.moveTo(0, j*cellSize + .5);
				ctx.lineTo(canvas.width, j*cellSize + .5);
			}

			for (var i = 0; i <= canvas.width/cellSize; i += 5) {
				ctx.moveTo(i*cellSize, 0);
				ctx.lineTo(i*cellSize, canvas.height);
			}

			for (var j = 0; j <= canvas.height/cellSize; j+= 5) {
				ctx.moveTo(0, j*cellSize);
				ctx.lineTo(canvas.width, j*cellSize);
			}

			ctx.strokeStyle = "lightblue";
			ctx.stroke();
		}
		
	</script>
</head>

<body onload="init()">
	<canvas id="mainCanvas" width="625" height="500"></canvas>
</body>
</html> 